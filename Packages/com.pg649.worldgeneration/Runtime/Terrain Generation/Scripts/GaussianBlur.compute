#pragma kernel GaussianBlurAddKeep3x3SD1
#pragma kernel GaussianBlurMultiplyKeep3x3SD1
#pragma kernel GaussianBlurAdd3x3SD1
#pragma kernel GaussianBlurMultiply3x3SD1
/* Kernel 3x3 SD=1 normalized
0.07511362	 0.1238414	 0.07511362

0.1238414	 0.20418	 0.1238414

0.07511362	 0.1238414	 0.07511362
*/

/* Kernel 3x3 SD=3 normalized
0.1069973	 0.1131098	 0.1069973

0.1131098	 0.1195715	 0.1131098

0.1069973	 0.1131098	 0.1069973
*/
static const float gauss_3x3_sd1_diag = 0.07511362;
static const float gauss_3x3_sd1_next = 0.1238414;
static const float gauss_3x3_sd1_center = 0.20418;

uint _size_safe;
uint _size_input;
uint _end_of_safe_zone;
StructuredBuffer<int> _mask;
StructuredBuffer<float> _input;
RWStructuredBuffer<float> _output;

// id.x is iterated over the smaller "safe zone" array -> lookups and writes have to be translated
[numthreads(256,1,1)]
void GaussianBlurAddKeep3x3SD1 (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _end_of_safe_zone) return; // stop after end of safe zone
    const uint row = (id.x / _size_safe) + 1; // integer division => row
    const uint col = (id.x % _size_safe) + 1; // modulo => column


    float sum = _input[row * _size_input + col]; // translated to input coords

    if(_mask[row * _size_input + col] == 1) {
        sum += _input[(row - 1) * _size_input + (col - 1)] * gauss_3x3_sd1_diag;
        sum += _input[(row - 1) * _size_input + (col)] * gauss_3x3_sd1_next;
        sum += _input[(row - 1) * _size_input + (col + 1)] * gauss_3x3_sd1_diag;
        sum += _input[(row) * _size_input + (col - 1)] * gauss_3x3_sd1_next;
        sum += _input[(row) * _size_input + (col)] * gauss_3x3_sd1_center;
        sum += _input[(row) * _size_input + (col + 1)] * gauss_3x3_sd1_next;
        sum += _input[(row + 1) * _size_input + (col - 1)] * gauss_3x3_sd1_diag;
        sum += _input[(row + 1) * _size_input + (col)] * gauss_3x3_sd1_next;
        sum += _input[(row + 1) * _size_input + (col + 1)] * gauss_3x3_sd1_diag;
        _output[row * _size_input + col] = sum;
    } else _output[row * _size_input + col] = _input[row * _size_input + col];
}

// id.x is iterated over the smaller "safe zone" array -> lookups and writes have to be translated
[numthreads(256,1,1)]
void GaussianBlurMultiplyKeep3x3SD1 (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _end_of_safe_zone) return; // stop after end of safe zone
    const uint row = (id.x / _size_safe) + 1; // integer division => row
    const uint col = (id.x % _size_safe) + 1; // modulo => column


    float sum = _input[row * _size_input + col]; // translated to input coords

    if(_mask[row * _size_input + col] == 1) {
        sum *= _input[(row - 1) * _size_input + (col - 1)] * gauss_3x3_sd1_diag;
        sum *= _input[(row - 1) * _size_input + (col)] * gauss_3x3_sd1_next;
        sum *= _input[(row - 1) * _size_input + (col + 1)] * gauss_3x3_sd1_diag;
        sum *= _input[(row) * _size_input + (col - 1)] * gauss_3x3_sd1_next;
        sum *= _input[(row) * _size_input + (col)] * gauss_3x3_sd1_center;
        sum *= _input[(row) * _size_input + (col + 1)] * gauss_3x3_sd1_next;
        sum *= _input[(row + 1) * _size_input + (col - 1)] * gauss_3x3_sd1_diag;
        sum *= _input[(row + 1) * _size_input + (col)] * gauss_3x3_sd1_next;
        sum *= _input[(row + 1) * _size_input + (col + 1)] * gauss_3x3_sd1_diag;
        _output[row * _size_input + col] = sum;
    } else _output[row * _size_input + col] = _input[row * _size_input + col];
}

// id.x is iterated over the smaller "safe zone" array -> lookups and writes have to be translated
[numthreads(256,1,1)]
void GaussianBlurAdd3x3SD1 (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _end_of_safe_zone) return; // stop after end of safe zone
    const uint row = (id.x / _size_safe) + 1; // integer division => row
    const uint col = (id.x % _size_safe) + 1; // modulo => column


    float sum = _input[row * _size_input + col]; // translated to input coords

    if(_mask[row * _size_input + col] == 1) {
        sum += _input[(row - 1) * _size_input + (col - 1)] * gauss_3x3_sd1_diag;
        sum += _input[(row - 1) * _size_input + (col)] * gauss_3x3_sd1_next;
        sum += _input[(row - 1) * _size_input + (col + 1)] * gauss_3x3_sd1_diag;
        sum += _input[(row) * _size_input + (col - 1)] * gauss_3x3_sd1_next;
        sum += _input[(row) * _size_input + (col)] * gauss_3x3_sd1_center;
        sum += _input[(row) * _size_input + (col + 1)] * gauss_3x3_sd1_next;
        sum += _input[(row + 1) * _size_input + (col - 1)] * gauss_3x3_sd1_diag;
        sum += _input[(row + 1) * _size_input + (col)] * gauss_3x3_sd1_next;
        sum += _input[(row + 1) * _size_input + (col + 1)] * gauss_3x3_sd1_diag;
        _output[row * _size_input + col] = sum;
    }
}

// id.x is iterated over the smaller "safe zone" array -> lookups and writes have to be translated
[numthreads(256,1,1)]
void GaussianBlurMultiply3x3SD1 (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _end_of_safe_zone) return; // stop after end of safe zone
    const uint row = (id.x / _size_safe) + 1; // integer division => row
    const uint col = (id.x % _size_safe) + 1; // modulo => column


    float sum = _input[row * _size_input + col]; // translated to input coords

    if(_mask[row * _size_input + col] == 1) {
        sum *= _input[(row - 1) * _size_input + (col - 1)] * gauss_3x3_sd1_diag;
        sum *= _input[(row - 1) * _size_input + (col)] * gauss_3x3_sd1_next;
        sum *= _input[(row - 1) * _size_input + (col + 1)] * gauss_3x3_sd1_diag;
        sum *= _input[(row) * _size_input + (col - 1)] * gauss_3x3_sd1_next;
        sum *= _input[(row) * _size_input + (col)] * gauss_3x3_sd1_center;
        sum *= _input[(row) * _size_input + (col + 1)] * gauss_3x3_sd1_next;
        sum *= _input[(row + 1) * _size_input + (col - 1)] * gauss_3x3_sd1_diag;
        sum *= _input[(row + 1) * _size_input + (col)] * gauss_3x3_sd1_next;
        sum *= _input[(row + 1) * _size_input + (col + 1)] * gauss_3x3_sd1_diag;
        _output[row * _size_input + col] = sum;
    }
}